## mysql概念

### 事务
- mysql中只有innodb引擎才支持事务

- 用于insert、delete、update操作

- 原子性：要么全部成功，要么全部失败

- 一致性：

- 隔离性：容许多个事务同时对数据进行操作，可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

- 持久性：事务执行完之后，对数据的修改是永久的，即使系统故障也不会丢失。

- 语句： start transaction、commit、rollback


### 事务隔离级别
- 未提交读
  - 描述：容许读取其它未提交的事务做的修改
  - 问题：会出现脏读
- 提交读（不可重复读）
  - 描述：容许读取其它已提交的事务做的修改
  - 问题：在同一个事务中两次读取相同的记录可能获取到不同的结果
- 可重复读
  - 描述：保证同一事务中读取到的记录一致，为innodb默认隔离级别。
  - 问题：幻读。当前事务获取的是某一范围内的数据时，另一个事务插入了数据，再次获取该范                      围内的数据时，会读取到这个幻行
- 可串行化
  - 描述：强制事务排序串行执行，从而解决幻读问题。通过在读的数据上加锁实现。
  - 问题：串行化降低并发性能；


### MVCC 多版本并发控制
- 作用：避免很多读情况下的加锁操作，提高并发操作。
- 实现：添加数据快照：行记录的创建时间 + 过期时间 + 事务的系统 版本号
- 限制：在InnoDB、solidDB等引擎中有，并且隔离级别为提交读、可重复读才支持
- 缺点：增加了额外的存储、做了额外的整理工作



### 死锁


### 事务日志

### 存储引擎
- MyISAM
- InnoDB

  #### 比较
  - InnoDB支持事务，MyISAM不支持事务。
  - InnoDB支持表级锁跟行级锁，而MyISAM只支持表级锁。
  - InnoDB支持外键
  - MyISAM支持全文索引


### 外键
- 作用：
  1. 做关联数据用的，避免一张表的数据不太过冗余（但是目前为止，没发现有用这个的）
  2. 保持关联数据的一致性
- 与主键的区别
  1. 主键，mysql会自动创建索引，外键则要主动指定索引，并且必须创建对应的索引。
  2. 主键不容许为空，不容许重复， 外键容许为空并且容许重复，如果外键不为空，则值一定为主表中已存在的值。
  3. 主键一个表只能存在一个， 而外键容许有多个。


### 多表联合查询

- 内连接
	select * from a_table a inner join b_table b on a.id = b.id;
  结果为交集
  
- 左连接
	select * from a_table a left join b_table b on a.id = b.id;
	结果为交集 + 左表全部记录
	
- 右连接
	select * from a_table a right join b_table b on a.id = b.id;
  结果为交集 + 右表全部记录
  
  ### 索引
- 索引类型
  1. B树索引：
    - 分为B树和B+树索引，大部分采用B+树索引
    - 有最左原则的限制（注意某个列使用范围查询之后，其右边的索引列无法再使用索引优化）
  2. 哈希索引：
    - 只有memory引擎显示支持建哈希索引。在innodb中是一种“自适应索引”，当某个索引值被频繁使用时，会在B树索引上在创建一个哈希索引。
    - 存储hash值和指向行数据的指针，如果hash值有冲突，则会用到链表
    - 无法进行排序、范围查找、比较查找，只支持精确匹配
  3. 空间数据索引：MyISAM表支持空间索引，可以用作地理数据存储
  4. 全文索引：用来加快查询文本中的关键字
- 索引的优点
  1. 减少扫描的行数
  2. 帮助服务器避免排序和创建临时表
  3. 随机I/O变顺序I/O
- 索引的缺点
  1. 增加的额外存储
  2. 由于CUD时需要维护索引，所以降低了数据的写维护速度。
- 为什么使用B树
  1. B树是多叉树，减少I/O次数
  2. B树是多叉搜索树，随机I/O变为顺序I/O
  2. 数据库的索引节点大小设置为一个页的大小（4K），而B树的节点是顺序排序的，而操作系统根据局部性原理加载附近的页，像order by这种查询能减少IO命中率。


##性能优化
- 方向：从执行时间和等待时间两个部分分析。
- 性能剖析：
  - 步骤：先测量任务花费的时间，在进行统计和排序。
  - 关注点：子任务执行的总时长、总占比、总调用次数、平均执行时间。
  - 优化点：减少子任务的调用次数、降低一次子任务执行的响应时间。
  - 理解：从长远的角度看，性能剖析的测量点不会导致响应变慢，而是帮助应用运行更快。
- 剖析mysql查询：
  - 全局剖析：
    方式：
    1. 通过设置loan_query_time为0开启所有查询的日志写到慢查询日志中。（常用）
    2. 用tcpdump抓包，然后用pt-query-digest工具的参数 --type=tcpdump进行分析。
    3. 通过mysql proxy代理层的脚本来记录所有查询及相关信息。（不建议）
  - 单条剖析：
    方式：
    1. show profile
    2. show status
    3. explain等工具
  - 诊断间歇性问题：
    方式：
    1. 写个脚本每秒执行show  global  status，收集数据，然后可以用gnuplot绘图查看曲线
    2. 写个脚本每秒执行show processlist，收集数据
    3. 慢查询日志或者tcpdump
    

## 数据类型
- 原则：
  1. 通常是越小越好，选择一个你认为不会超过范围的最小类型。
  2. 越简单越好。比如用date而不是字符串存储时间，用整型存储而不是字符串存储ip。
  3. 尽量避免NULL，除非你就是要存储NULL。
  4. 对于标识列，应该谨慎选择类型，整数类型是最好的选择。
- 整型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT 分别为8、16、24、32、64
- 实数类型：
  1. 类型：float、double、decimal(M,D) 分别为4、8、M+2
  2. 建议：一般建议采用bigint存储然后乘以一个精度值，如果的确要存储浮点型，建议用                        decimal，因为float、double会产生误差，但是decimal是mysql5.0之后自己实现的精确计                算，性能会低些。
- 字符串类型：
  1. char：分配固定长度大小的空间，并且会删除所有的末尾空格。适合存储所有值接近同一长度的字符串，如MD5， 适合存储比较短的字符串，应为不会有额外的1/2字节，如Y/N等。
  2. varchar：分配的空间更具实际需要分配，对于长度很不一致的字符串存储来说，varchar比char更省空间，另外varchar会额外用1个字节（255）或者2个字节（255以上）存储字符串的长度，根据声明varchar(256)时决定。对于长度边长的更新，由于当前页存储不下，可能会造成分裂页的动作。
  3. binary和varbinary：分别存储定长二进制字符串和可边长二进制字符串
  4. blob：存储很大的二进制数据，有tinyblob、smallblob、blob、mediumblob、longblob
  5. text：存储很大的字符串，有tinytext、smalltext、text、mediumtext、longtext
  6. 当blob和text存储的值很大时，mysql会在行外存储这些值，在行内用指针指向外部存储。
  7. enum枚举列：在创建表时指定所有枚举字符串，如果要修改枚举只能用alter table，并且在存储的列中保存的是数字，在表的.frm中保存数字-字符串的映射，并且索引是通过数字排序
- 日期类型：
  1. timestamp: 用4个字节存储，从1970~2038年，与时区有关，列属性为not null, 并且插入时默认为设置为当前时间。
  2. datetime：用8个字节存储，从1001~9999年，与时区无关。
- 位数据类型：
  1. bit
  2. set：mysql在内部使用整数存储enum和set，在做比较操作时转换为字符串。

### 范式和反范式
- 范式：
  1. 优点：
    - 数据冗余度小
    - 更新操作较快
    - 表通常较小
  2. 缺点：
    - 需要更多的关联操作，导致了随机I/O
    - 可能导致索引测量失效
- 反范式：和范式的优缺点相反
- 一般是范式和反范式混合使用


### 放慢写，加快读
- 汇总表
  - 模糊读：建一个汇总表，每隔一段时间进行汇总并更新汇总表
  - 实时读：读取过去一段时间的汇总表 + 最近的实时数据
- 缓存表：
- 计数器表：
  建一个单独的计数器表，包含slot、count，update counter set count = count + 1 where rand() * 100, 最后用select sum(count) from counter 统计
- 物化视图：
  功能：可以根据增量添加的数据进行汇总统计。
  工具：flexviews

### 加快alter table
- 用 alter table table_a alter column column_a set DEFAULT '1'; 修改.frm文件
- 在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换
- 影子拷贝，即创建表、重命名、删表


## 高性能索引

- 创建伪哈希索引：
  - 说明：对于长度很长的字符串，可以添加一个int类型的哈希列，加快查询速度
  - 哈希函数：用CRC32哈希函数，不要使用SHA1和MD5。数据量很大时， 也可以自己弄一个哈希函数，比如 CONV(RIGHT(MD5(http://xxx.com), 16), 16, 10)
  - 一般做法：
    1. 触发器定义insert和update语句，生成对应的哈希值
    2. select时使用 select id from table_url where url_crc=CRC("xxx") and url = "xxx", 加后面的url="xxx"可以避免哈希冲突



























- 

  


